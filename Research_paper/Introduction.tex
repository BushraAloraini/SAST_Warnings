\section{Introduction}
Cyberattack has became a significant universal threat that poses a very serious economic loss, reputational damage, and could expose organizations to legal consequences, such as negligence claims and the failure to meet contractual obligations \cite{mcafee2014}. It is anticipated that upcoming years will witness more cyberattacks due to the emerging of the Internet of Things technologies which could influence everyone \cite{securitynewsdesk2017}. Hence, cybersecurity has become a significant concern. 

Despite that there are several security defense solutions are introduced ever since, however building secure software in the first place is the first line of defense. In fact, software security vulnerabilities are estimated to be one of the most used attack vector by attacker rated as 60-90\% of all attacks \cite{heimdalsecurity2016}. Therefore, software testing to ensure software security has attracted much attention in software engineering community. Static analysis is one way used during software testing to find security vulnerabilities early during the coding phase. This leads to cost saving which is a key benefit of static analysis tools \cite{soni2006defect}.  

Static analysis tools are used to analyses the source or binary code of the program without executing it. These tools could provide various insights into the program's code, such as analyzing its structures and dependencies, providing code metrics, detecting bugs, etc. In this paper, we are interested in studying static analysis tools that detect one of the most dangerous and frequent type of venerabilities, buffer overflow \cite{Cowan2003}.  There are multiple static analysis methods and tools that were introduced to detect such vulnerability during coding phase. These different static analysis tools adopt different analysis methods to detect buffer overflow. In fact , different static analysis tools that target buffer overflow vulnerabilities could be able to detect some variants of buffer overflow vulnerabilities but not others.

In this study, we want to study the capabilities and the effectiveness of static analysis tools that could detect buffer overflow vulnerabilities in C++. However, instead of running static analysis tools against test cases to measure the efficiency and capability, we want to evaluate such static analysis tools against real applications. That is because real applications contain real vulnerabilities and not vulnerabilities that were built based on a specific assumption in which static analysis tools know those kind of assumed vulnerabilities (and potentially built based on that to detect those assumed vulnerabilities). Indeed, a study by the National Security Agency (NSA) \cite{nsa2011} has emphasized the importance of evaluating static analysis tools against real applications to more  precisely predict the frequencies of bugs outside of controlled studies.

Large repositories could provide a great opportunity in this matter. Large repositories maintain rich historical data, such as the code changes, bugs and issues history,  how software evolved over time, etc. Buffer overflow could potentially introduce to the software at a certain time, then it could be removed  at another time. In fact, studying bugs at large repository not only gives us the true story about the bug but also it could provide more information regarding that discovered bugs such as bug frequency, pattern, and age.  

Therefore, our study focus on studying the effectiveness of static analysis tools by utilizing information provided by large repositories. In particular, we want to see how efficient static analysis tools are in detecting such vulnerability, and are these static analysis tools able to detect real vulnerabilities.  We measure the efficiency in terms of false positive rate, the precision, and running time.  Also, we want to investigate whether buffer overflow bugs have a specific pattern that leads to be detected by static analysis tools. Moreover, we want to study how these detected vulnerabilities evolved over time and how frequent are they. So, we will investigate that by examining the following RQs: 